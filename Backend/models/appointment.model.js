const mongoose = require('mongoose');

const appointmentSchema = new mongoose.Schema({
  appointmentId: {
    type: String,
    unique: true
    // Note: Will be auto-generated by pre-save hook
    // Not required since it's auto-generated
  },
  patient: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  doctor: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  department: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Department',
    required: true
  },
  appointmentDate: {
    type: Date,
    required: true
  },
  appointmentTime: {
    type: String,
    required: true,
    match: [/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Please enter time in HH:MM format']
  },
  duration: {
    type: Number,
    default: 30, // minutes
    min: 15,
    max: 180
  },
  type: {
    type: String,
    enum: ['consultation', 'follow-up', 'emergency', 'routine-checkup', 'procedure', 'telemedicine'],
    required: true
  },
  status: {
    type: String,
    enum: ['scheduled', 'confirmed', 'in-progress', 'completed', 'cancelled', 'no-show', 'rescheduled'],
    default: 'scheduled'
  },
  priority: {
    type: String,
    enum: ['low', 'normal', 'high', 'urgent'],
    default: 'normal'
  },
  // Appointment Details
  chiefComplaint: {
    type: String,
    required: true,
    maxlength: 500
  },
  symptoms: [String],
  notes: {
    type: String,
    maxlength: 1000
  },
  // Scheduling Information
  scheduledBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  // Confirmation and Reminders
  confirmationStatus: {
    type: String,
    enum: ['pending', 'confirmed', 'declined'],
    default: 'pending'
  },
  remindersSent: [{
    type: {
      type: String,
      enum: ['email', 'sms', 'phone']
    },
    sentAt: Date,
    status: {
      type: String,
      enum: ['sent', 'delivered', 'failed']
    }
  }],
  // Telemedicine specific fields
  telemedicine: {
    isTelemedicine: {
      type: Boolean,
      default: false
    },
    meetingLink: String,
    meetingId: String,
    platform: {
      type: String,
      enum: ['zoom', 'teams', 'google-meet', 'custom']
    }
  },
  // Visit Information (filled during/after appointment)
  visitInfo: {
    checkInTime: Date,
    checkOutTime: Date,
    actualDuration: Number, // in minutes
    vitalSigns: {
      bloodPressure: {
        systolic: Number,
        diastolic: Number
      },
      heartRate: Number,
      temperature: Number,
      weight: Number,
      height: Number,
      oxygenSaturation: Number
    },
    diagnosis: [{
      code: String, // ICD-10 code
      description: String,
      type: {
        type: String,
        enum: ['primary', 'secondary', 'differential']
      }
    }],
    treatment: {
      procedures: [String],
      medications: [{
        name: String,
        dosage: String,
        frequency: String,
        duration: String,
        instructions: String
      }],
      recommendations: [String]
    },
    followUpRequired: {
      type: Boolean,
      default: false
    },
    followUpDate: Date,
    followUpInstructions: String
  },
  // Billing Information
  billing: {
    consultationFee: {
      type: Number,
      default: 0
    },
    additionalCharges: [{
      description: String,
      amount: Number
    }],
    totalAmount: {
      type: Number,
      default: 0
    },
    paymentStatus: {
      type: String,
      enum: ['pending', 'paid', 'partially-paid', 'refunded'],
      default: 'pending'
    },
    insuranceClaimed: {
      type: Boolean,
      default: false
    }
  },
  // Cancellation/Rescheduling
  cancellation: {
    cancelledAt: Date,
    cancelledBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    reason: String,
    refundAmount: Number
  },
  rescheduling: {
    originalDate: Date,
    originalTime: String,
    rescheduledAt: Date,
    rescheduledBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    reason: String
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for appointment date and time combined
appointmentSchema.virtual('appointmentDateTime').get(function () {
  if (this.appointmentDate && this.appointmentTime) {
    const [hours, minutes] = this.appointmentTime.split(':');
    const dateTime = new Date(this.appointmentDate);
    dateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    return dateTime;
  }
  return null;
});

// Virtual for end time
appointmentSchema.virtual('endDateTime').get(function () {
  const startTime = this.appointmentDateTime;
  if (startTime) {
    return new Date(startTime.getTime() + (this.duration * 60000));
  }
  return null;
});

// Virtual for duration in hours and minutes
appointmentSchema.virtual('durationFormatted').get(function () {
  const hours = Math.floor(this.duration / 60);
  const minutes = this.duration % 60;
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
});

// Indexes for better performance
// appointmentId index is already created by unique: true in schema
appointmentSchema.index({ patient: 1, appointmentDate: 1 });
appointmentSchema.index({ doctor: 1, appointmentDate: 1 });
appointmentSchema.index({ department: 1, appointmentDate: 1 });
appointmentSchema.index({ status: 1 });
appointmentSchema.index({ appointmentDate: 1, appointmentTime: 1 });

// Generate appointment ID before validation and saving
appointmentSchema.pre('validate', async function (next) {
  if (!this.appointmentId) {
    const count = await this.constructor.countDocuments();
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = String(date.getMonth() + 1).padStart(2, '0');
    this.appointmentId = `APT${year}${month}${String(count + 1).padStart(4, '0')}`;
  }
  next();
});

// Method to check for conflicts
appointmentSchema.statics.checkConflicts = async function (doctorId, appointmentDate, appointmentTime, duration = 30, excludeId = null) {
  try {
    const [hours, minutes] = appointmentTime.split(':');
    const startTime = new Date(appointmentDate);
    startTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    const endTime = new Date(startTime.getTime() + (duration * 60000));

    const query = {
      doctor: doctorId,
      appointmentDate: appointmentDate,
      status: { $in: ['scheduled', 'confirmed', 'in-progress'] }
    };

    if (excludeId) {
      query._id = { $ne: excludeId };
    }

    const existingAppointments = await this.find(query);

    for (let appointment of existingAppointments) {
      // Manually calculate existing appointment times
      const [existingHours, existingMinutes] = appointment.appointmentTime.split(':');
      const existingStart = new Date(appointment.appointmentDate);
      existingStart.setHours(parseInt(existingHours), parseInt(existingMinutes), 0, 0);
      const existingEnd = new Date(existingStart.getTime() + ((appointment.duration || 30) * 60000));

      // Check for overlap
      if ((startTime < existingEnd) && (endTime > existingStart)) {
        return {
          hasConflict: true,
          conflictingAppointment: appointment
        };
      }
    }

    return { hasConflict: false };
  } catch (error) {
    console.error('Error in checkConflicts:', error);
    // Return no conflict if there's an error to allow appointment creation
    return { hasConflict: false };
  }
};

// Method to update status
appointmentSchema.methods.updateStatus = function (newStatus, updatedBy) {
  this.status = newStatus;

  if (newStatus === 'in-progress' && !this.visitInfo.checkInTime) {
    this.visitInfo.checkInTime = new Date();
  }

  if (newStatus === 'completed' && !this.visitInfo.checkOutTime) {
    this.visitInfo.checkOutTime = new Date();
    if (this.visitInfo.checkInTime) {
      this.visitInfo.actualDuration = Math.round(
        (this.visitInfo.checkOutTime - this.visitInfo.checkInTime) / (1000 * 60)
      );
    }
  }

  return this.save();
};

module.exports = mongoose.model('Appointment', appointmentSchema);